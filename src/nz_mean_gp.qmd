---
title: Non-zero mean field GP
Author: Ibrohim Nosirov
Date: 20 July 2025
---

Random sampling.
```{julia}
function kronecker_quasirand(d, N, start=0)
    φ = 1.0 + 1.0/d
    for k = 1:10
        gφ = φ^(d+1) - φ - 1
        dgφ = (d+1)*φ^d - 1
        φ -= gφ/dgφ
    end
    αs = [mod(1.0/φ^j, 1.0) for j=1:d]

    # Compute the quasi-random sequence
    Z = zeros(d, N)
    for j = 1:N
        for i = 1:d
            Z[i,j] = mod(0.5 + (start+j)*αs[i], 1.0)
        end
    end
    Z
end
```

Finite difference check.
```{julia}
function check_approx(xref, x; rtol=1e-6, atol=0.0)
    abserr = norm(xref-x)
    refnorm = norm(xref)
    if abserr > rtol*refnorm + atol
        error("Check failed ($x v $xref): $abserr > $rtol * $refnorm + $atol")
    end
    abserr/refnorm
end

diff_fd(f, x; h=1e-6) = (f(x+h)-f(x-h))/(2h) # this is a function in assignment form.
# NOTE: the last expression evaluated is a function's # return value.

check_fd(df_ref, f, x; h=1e-6, rtol=1e-6, atol=0.0) =
    check_approx(df_ref, diff_fd(f, x, h=h), rtol=rtol, atol=atol)
```

define kernel.
```{julia}
using DispatchDoctor: @stable
@stable function Dφ_SE(s)
    φ = exp(-s^2/2)
    dφ_div = -φ
    dφ = dφ_div*s
    Hφ = (-1 + s^2)*φ
    φ, dφ_div, dφ, Hφ
end

let
s = 2.0
Dφ_SE(s)
end

@stable function dist2(x :: AbstractVector{T}, y :: AbstractVector{T}) where {T}
    s = zero(T)
    for k = 1:length(x)
        dk = x[k] - y[k]
        s += dk * dk
    end
    s
end

@stable dist(x :: AbstractVector{T}, y :: AbstractVector{T}) where {T} = sqrt(dist2(x,y))

let
x = randn(10)
y = randn(10)
# including vs not including {T} doesn't make any difference.
@time dist(x,y)
end
# TODO: write the finite difference check.
```

### define kernel context

```{julia}
abstract type KernelContext end
# Question for David
# this is just custom pretty-printing?
(ctx :: KernelContext)(args ...) = kernel(ctx, args ... )

abstract type RBFKernelContext{d} <: KernelContext end
ndims(::RBFKernelContext{d}) where {d} = d

function getθ(ctx :: KernelContext)
    θ = zeros(nhypers(ctx))
    getθ!(θ, ctx)
    θ
end
```
```{julia}
macro rbf_simple_kernel(T, φ_rbf, Dφ_rbf)
    T, φ_rbf, Dφ_rbf = esc(T), esc(φ_rbf), esc(Dφ_rbf)
    quote
        struct $T{d} <: $(esc(:RBFKernelContext)){d}
            l :: Float64
        end
        $(esc(:φ))(::$T, s) = $φ_rbf(s)
        $(esc(:Dφ))(::$T, s) = $Dφ_rbf(s)
        $(esc(:nhypers))(::$T) = 1
        $(esc(:getθ!))(θ, ctx :: $T) = θ[1]=ctx.l
        $(esc(:updateθ))(ctx ::$T{d}, θ) where {d} = $T{d}(θ[1])
    end
end

@rbf_simple_kernel(KernelSE, φ_SE, Dφ_SE)

kernel(ctx :: RBFKernelContext, x :: AbstractVector, y :: AbstractVector) =
    φ(ctx, dist(x, y)/ctx.l)

# gradient of k with respect to hyperparameters
function gθ_kernel!(g :: AbstractVector, ctx :: RBFKernelContext,
                    x :: AbstractVector, y :: AbstractVector, c=1.0)
    l = ctx.l
    s = dist(x,y)/l
    _, _, dφ, _ = Dφ(ctx, s)
    g[1] -= c*dφ*s/l
    g
end
```

```{julia}
function Hθ_kernel!(H :: AbstractMatrix, ctx :: RBFKernelContext,
                    x :: AbstractVector, y :: AbstractVector, c=1.0)
    l = ctx.l
    s = dist(x,y)/l
    _, _, dφ, Hφ = Dφ(ctx, s)
    H[1,1] += c*(Hφ*s + 2*dφ)*s/l^2
    H
end

# gradient of k with respect to hyperparameters
function gθ_kernel!(g :: AbstractVector, ctx :: RBFKernelContext,
                    x :: AbstractVector, y :: AbstractVector, c=1.0)
    l = ctx.l
    s = dist(x,y)/l
    _, _, dφ, _ = Dφ(ctx, s)
    g[1] -= c*dφ*s/l
    g
end

function Hθ_kernel!(H :: AbstractMatrix, ctx :: RBFKernelContext,
                    x :: AbstractVector, y :: AbstractVector, c=1.0)
    l = ctx.l
    s = dist(x,y)/l
    _, _, dφ, Hφ = Dφ(ctx, s)
    H[1,1] += c*(Hφ*s + 2*dφ)*s/l^2
    H
end

function gx_kernel!(g :: AbstractVector, ctx :: RBFKernelContext,
                    x :: AbstractVector, y :: AbstractVector, c=1.0)
    l = ctx.l
    d = ndims(ctx)
    ρ = dist(x,y)
    s = ρ/l
    _, _, dφ, _ = Dφ(ctx, s)
    if ρ != 0.0
        dφ /= ctx.l
        C = c*dφ/ρ
        for i = 1:d
            g[i] += C*(x[i] - y[i])
        end
    end
    g
end

function Hx_kernel!(H :: AbstractMatrix, ctx :: RBFKernelContext,
                    x :: AbstractVector
```


### define GPP context


### hyperparameter tuning


### acquisition functions

